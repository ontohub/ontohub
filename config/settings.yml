#
# Project configuration
#
# One may use the following settings files to change or overwrite the defaults:
#
# config/settings.yml         (this one - common settings and its documentation)
# config/settings/<env>.yml	  (some as above but specific for the named RB_ENV)
# config/environments/<env>.yml   (analog above)
# config/settings.local.yml       (common settings local to this machine)
# config/settings/<env>.local.yml (some as above but specific for named RB_ENV)
# config/environments/<env>.local.yml  (analog above)
#
# The files are read in the shown order above. A file read later takes
# precendence. Missing files get silently ignored.
# For now only merges occure. However, if two settings with the same name have
# a different type, the latter replaces the previous one completely. For details
# see https://github.com/railsconfig/rails_config/blob/master/lib/rails_config/vendor/deep_merge.rb

# Hostname of this machine.
#hostname: your_FQDN

# Logging level to use (fatal, error, warn, info, debug). Default:
#log_level: info

# Whether to consider all HTTP requests to be local and thus emit the details
# if an error occures. Otherwise a "user friendly" page gets shown, which hides
# the glorios and perhaps even security sensitive details. Default: false for
# production, otherwise true.
#consider_all_requests_local: false

# Send exception via email to certain recipients. This has DoS attack potential
# and thus is disabled by default. Example:
#exception_notifier:
#  enabled: false
#  mail_prefix: "[ontohub staging exception]"
#  sender_address: "exceptions@ontohub.do.main"
#  exception_recipients:
#    - exception-recipient@do.main

# A sequence of arbitrary characters to use as secret token or key, e.g. to
# generate session keys, cookies or other secrets. Should have 30 or more
# characters. One may generate such a key e.g. using the following command:
#   openssl rand -hex -rand /var/log/messages:~/.history  64   2>/dev/null
# Put the generated key in your config/settings.local.yml like this:
#secret_token: a-random-character-string

# Default sender address for outgoing mail. Default:
#email: noreply@your_FQDN

# Mail delivery settings.
# Here the same settings but 'delivery_method' are taken by default as shown on
# http://api.rubyonrails.org/classes/ActionMailer/Base.html#class-ActionMailer::Base-label-Configuration+options
# If delivery_method is not explicitly set, it gets set to 'sendmail' if
# /usr/{sbin|lib}/sendmail executable is available, otherwise 'smtp' gets set.
# NOTE: The logger and default_options properties are ignored - ontohub defaults
# are used instead. For convinience here the defaults in yaml notation (~ means
# unset or nil):
#
#action_mailer:
#  perform_deliveries: true     # for test false
#  raise_delivery_errors: false # for production, otherwise true
#  delivery_method: sendmail    # {sendmail|smtp|file|test}
#  sendmail_settings:
#    location: /usr/sbin/sendmail
#    arguments: '-i -t'
#  smtp_setting:
#    # the name or IP address of the mail gateway to use
#    address: mail
#    port: 25
#    # WARNING: This is a misnomer! It has nothing to do with a 'DNS domain' or
#    # something like this. If you wanna/need to set it, set it to the fully
#    # qualified domain name of your machine under which other mail gateways see
#    # it by resolving its IP address (nslookup a.b.c.d). Otherwise don't wonder
#    # if the mails aren't accepted for delivery by foreign mail servers!!!
#    domain: ~
#    user_name: ~
#    password: ~
#    authentication: ~      # {plain|login|cram_md5}
#    enable_starttls_auto: true
#    openssl_verify_mode: ~ # {none|peer|client_once|fail_if_no_peer_cert}
#  file_settings:
#    location: tmp/mail     # relative to the application base dir


# The following settings have usually an influence on the generated web pages.
# So if you change any settings or if in doubt, you should precompile all
# assets again and restart the webserver, e.g.:
# cd ontohub ; umask 002 ; ../bin/rake assets:precompile
# ~ontohub/etc/puma-serv.sh restart


# The name of this instance.
#name: "MyOntohub"

# Asset host to use for delivery of static files (css, images, javascripts).
# Default:
#asset_host: ~

# Whether to show the 'Symbols' navbar menu entry for symbol searches. Default:
#display_symbols_tab: false

# Whether to show a file format selection (json|xml) menu where appropriate.
# Default:
#format_selection: false

# Show the git revision of this ontohub instance in the web page footer.
# Default: false for production, true otherwise.
#display_head_commit: false

# Footer links and texts. Default:
#footer:
#  - text: Imprint
#    href: http://about.ontohub.org/
#  - text: Source Code
#    href: https://github.com/ontohub/ontohub

# The number of days a user can access the website without confirming his
# account after registration. 0 => no access without confirmation. Default:
#allow_unconfirmed_access_for_days: 3

# An undocumented feature - don't use.
#access_token:
#  expiration_minutes: 360

# NOTE:
# The user who's running the git service should have the same group as the user
# who is running the web service and the related files/directories below
# git:data_dir should be group writeable. This avoids headaches e.g. wrt. non-
# cross platform ACLs (e.g. most Linux based FS impl. according to a withdrawn
# ancient POSIX standard or NFSv4/ZFS/NTFS ACL impl.). However, this does not
# work for ssh authorized_keys: this requires a different approach - see
# script/cp_keys.c for more information. Default:
#git:
#  # Where all git related data gets stored. If this directory contains a file
#  # 'maintenance.txt', the application assumes it is in maintenance mode. The
#  # web service frontend might hide this state by showing or redirecting to a
#  # different static page. The git service or to be more specific the
#  # git/bin/git-shell doesn't accept any command as long as this file exists.
#  data_dir: /data/git
#  verify_url: http://localhost/
#  default_branch: 'master'
#  push_priority:
#    commits: 1
#    changed_files_per_commit: 5
#  fallbacks:
#    # When changes are made to an ontology via web, the web service needs to
#    # commit these changes using git, which in turn expects a user and email
#    # address. So if the related user is not logged in (public writable repo)
#    # these settings will be used.
#    user: 'ontohub_system'
#    email: 'ontohub_system@ontohub.org'
#    repo_name: 'External'

# Number of hets workers aka processes to use. Default:
#workers:
#  hets: 4

# Timeout for ontology parsing jobs in hours. Default:
#ontology_parse_timeout: 6

# Limits for displaying file contents and diffs. Defaults:
#max_read_filesize: 524_288
#max_combined_diff_size: 1_048_576

allowed_iri_schemes:
  - http
  - https
  - file
  - gopher
  - urn

# Generalizing term "Ontology",ALternatives are M:Models and S:Specification
OMS: ontology
# In case of Model,this should be used.
OMS_qualifier: modeling

# Possible values for metadata, adapted from OMV
formality_levels:
  - name: vocabulary 
    description: "list of words"
  - name: terminology
    description: "list of concepts with definitions"
  - name: taxonomy
    description: "terminology with subsumption hierarchy"
  - name: axiomatization
    description: "ontology with axioms beyond a pure subsumption hierarchy"
    # number of axioms per concept can be displayed

license_models:
  - name: Apple Public Source License (APSL)
    url: http://www.opensource.apple.com/license/apsl/
  - name: Open Software License (OSL)
    url: http://opensource.org/licenses/OSL-3.0
  - name: General Public License (GPL)
    url: http://www.gnu.org/licenses/gpl.html
  - name: IBM Public License (IBM PL)
    url: http://opensource.org/licenses/IPL-1.0
  - name: Common Public License (CPL)
    url: http://www.eclipse.org/legal/cpl-v10.html
  - name: Lesser General Public License (LGPL)
    url: https://www.gnu.org/licenses/lgpl.html
  - name: INTEL Open Source License (INTEL OSL)
    url: http://opensource.org/licenses/Intel
  - name: Modified BSD License (mBSD)
    url: http://opensource.org/licenses/BSD-3-Clause
  - name: Academic Free License (AFL)
    url: http://opensource.org/licenses/AFL-3.0

ontology_types:
  - name: Upper Level Ontology
    description: describes general, domain-independent concepts e.g. space, time
    documentation: http://www.example.com
  - name: Core Ontology
    description: "describes the most important concepts in a specific domain (also: mid-level ontology)"
    documentation: http://www.example.com
  - name: Domain Ontology
    description: describes some domain of the world
    documentation: http://www.example.com
  - name: Application Ontology
    description: describes some domain in an application-dependent manner
    documentation: http://www.example.com

tasks:
  - name: SearchTask
    description: the task characterizes how ontologies are used to refine common keywordbased search algorithms using domain knowledge in form of subsumption relations. Ontology-driven search is usually performed automatically by means of reasoning services handling particular aspects of an ontology representation language.
  - name: AnnotationTask
    description: the ontology is used as a controlled vocabulary to annotate Semantic Web resources. This task includes the usage of a semantically rich ontology for representing arbitrarily complex annotation statements on these resources. The task can be performed manually or (semi-)automatically.
  - name: QueryRewritingTask
    description: complementary to the query formulation dimension, this task applies ontologies to semantically optimize query expressions by means of the domain knowledge (constraints, subsumption relations etc.) The task can be interpreted as a particular art of filtering information. The task is performed automatically; however, it assumes the availability of patterns describing the transformations at query level.
  - name: FilteringTask
    description: the task describes at a very general level how ontologies are applied to refine the solution space of a certain problem, such as information retrieval or personalization. The task is targeted at being performed semi-automatically or automatically.
  - name: IntegrationTask
    description: the task characterizes how ontologies provide an integrating environment, an inter-lingua, for information repositories or software tools. In this scenario the ontology is applied (semi-)automatically to merge between heterogeneous data pools in the same or in adjacent domains.
  - name: QueryFormulationTask
    description: the ontology is used in information retrieval settings as a controlled vocabulary for representing user queries. Usually the task is performed automatically in that the concepts of the ontology is are listed in a query formulation front-end in order to allow users to specifies their queries.
  - name: MediationTask
    description: the ontology is built to reduce the ambiguities between communicating human or machine agents. It can act as a normative model which formally and clearly defines the meaning of the terms employed in agent interactions. In the context of programmed agents, the task is envisioned to be performed automatically.
  - name: ConfigurationTask
    description: the ontology is designed to provide a controlled and unambiguous means to represent valid configuration profiles in application systems. As the aim of the ontology is to support the operationalization of particular system-related processes; this task is performed automatically in that the ontology is processed in an automatic manner by means of reasoners or APIs.
  - name: PersonalizationTask
    description: the ontology is used mainly for providing personalized access to information resources. Individual user preferences w.r.t. particular application settings are formally specified by means of an ontology, which, in conjunction with appropriate reasoning services, can be directly integrated to a personalization component for filtering purposes. The usage of ontologies in personalization tasks might be carried out in various forms, from a direct involvement of the user who manually specifies ontological concepts which optimally describe his preferences, to the ontological modelling of user profiles.
  - name: IndexingTask
    description: in this scenario, the goal of the ontology is to provide a clearly defined classification and browsing structure for the information items in a repository. Again, the task can be performed manually by domain experts or as part of an application in an automatic or semi-automatic way.
  - name: MatchingTask
    description: the goal of matching is to establish links between semantically similar data items in information repositories. In contrast to the previous task, matching does not include the production of a shared final schema/ontology as a result of aggregating the matched source elements to common elements. W.r.t. the automatization level the range varies from manual to fully-automatical execution.
